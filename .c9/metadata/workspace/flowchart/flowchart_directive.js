{"changed":true,"filter":false,"title":"flowchart_directive.js","tooltip":"/flowchart/flowchart_directive.js","value":"//\n// Flowchart module.\n//\nangular.module('flowChart', ['dragging'] )\n\n//\n// Directive that generates the rendered chart from the data model.\n//\n.directive('flowChart', function() {\n  return {\n  \trestrict: 'E',\n  \ttemplateUrl: \"flowchart/flowchart_template.html\",\n  \treplace: true,\n  \tscope: {\n  \t\tchart: \"=chart\",\n  \t},\n\n  \t//\n  \t// Controller for the flowchart directive.\n  \t// Having a separate controller is better for unit testing, otherwise\n  \t// it is painful to unit test a directive without instantiating the DOM \n  \t// (which is possible, just not ideal).\n  \t//\n  \tcontroller: 'FlowChartController',\n  };\n})\n\n//\n// Directive that allows the chart to be edited as json in a textarea.\n//\n.directive('chartJsonEdit', function () {\n\treturn {\n\t\trestrict: 'A',\n\t\tscope: {\n\t\t\tviewModel: \"=\"\n\t\t},\n\t\tlink: function (scope, elem, attr) {\n\n\t\t\t//\n\t\t\t// Serialize the data model as json and update the textarea.\n\t\t\t//\n\t\t\tvar updateJson = function () {\n\t\t\t\tif (scope.viewModel) {\n\t\t\t\t\tvar json = JSON.stringify(scope.viewModel.data, null, 4);\n\t\t\t\t\t$(elem).val(json);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t//\n\t\t\t// First up, set the initial value of the textarea.\n\t\t\t//\n\t\t\tupdateJson();\n\n\t\t\t//\n\t\t\t// Watch for changes in the data model and update the textarea whenever necessary.\n\t\t\t//\n\t\t\tscope.$watch(\"viewModel.data\", updateJson, true);\n\n\t\t\t//\n\t\t\t// Handle the change event from the textarea and update the data model\n\t\t\t// from the modified json.\n\t\t\t//\n\t\t\t$(elem).bind(\"input propertychange\", function () {\n\t\t\t\tvar json = $(elem).val();\n\t\t\t\tvar dataModel = JSON.parse(json);\n\t\t\t\tscope.viewModel = new flowchart.ChartViewModel(dataModel);\n\n\t\t\t\tscope.$digest();\n\t\t\t});\n\t\t}\n\t}\n\n})\n\n//\n// Controller for the flowchart directive.\n// Having a separate controller is better for unit testing, otherwise\n// it is painful to unit test a directive without instantiating the DOM \n// (which is possible, just not ideal).\n//\n.controller('FlowChartController', ['$scope', 'dragging', '$element', function FlowChartController ($scope, dragging, $element) {\n\n\tvar controller = this;\n\n\t//\n\t// Reference to the document and jQuery, can be overridden for testting.\n\t//\n\tthis.document = document;\n\n\t//\n\t// Wrap jQuery so it can easily be  mocked for testing.\n\t//\n\tthis.jQuery = function (element) {\n\t\treturn $(element);\n\t}\n\n\t//\n\t// Init data-model variables.\n\t//\n\t$scope.draggingConnection = false;\n\t$scope.connectorSize = 10;\n\t$scope.dragSelecting = false;\n\t/* Can use this to test the drag selection rect.\n\t$scope.dragSelectionRect = {\n\t\tx: 0,\n\t\ty: 0,\n\t\twidth: 0,\n\t\theight: 0,\n\t};\n\t*/\n\n\t//\n\t// Reference to the connection, connector or node that the mouse is currently over.\n\t//\n\t$scope.mouseOverConnector = null;\n\t$scope.mouseOverConnection = null;\n\t$scope.mouseOverNode = null;\n\n\t//\n\t// The class for connections and connectors.\n\t//\n\tthis.connectionClass = 'connection';\n\tthis.connectorClass = 'connector';\n\tthis.nodeClass = 'node';\n\n\t//\n\t// Search up the HTML element tree for an element the requested class.\n\t//\n\tthis.searchUp = function (element, parentClass) {\n\n\t\t//\n\t\t// Reached the root.\n\t\t//\n\t\tif (element == null || element.length == 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// \n\t\t// Check if the element has the class that identifies it as a connector.\n\t\tif (hasClassSVG(element, parentClass)) {\n\t\t//\n\t\t\t//\n\t\t\t// Found the connector element.\n\t\t\t//\n\t\t\treturn element;\n\t\t}\n\n\t\t//\n\t\t// Recursively search parent elements.\n\t\t//\n\t\treturn this.searchUp(element.parent(), parentClass);\n\t};\n\n\t//\n\t// Hit test and retreive node and connector that was hit at the specified coordinates.\n\t//\n\tthis.hitTest = function (clientX, clientY) {\n\n\t\t//\n\t\t// Retreive the element the mouse is currently over.\n\t\t//\n\t\treturn this.document.elementFromPoint(clientX, clientY);\n\t};\n\n\t//\n\t// Hit test and retreive node and connector that was hit at the specified coordinates.\n\t//\n\tthis.checkForHit = function (mouseOverElement, whichClass) {\n\n\t\t//\n\t\t// Find the parent element, if any, that is a connector.\n\t\t//\n\t\tvar hoverElement = this.searchUp(this.jQuery(mouseOverElement), whichClass);\n\t\tif (!hoverElement) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn hoverElement.scope();\n\t};\n\n\t//\n\t// Translate the coordinates so they are relative to the svg element.\n\t//\n\tthis.translateCoordinates = function(x, y, evt) {\n\t\tvar svg_elem =  $element.get(0);\n\t\tvar matrix = svg_elem.getScreenCTM();\n\t\tvar point = svg_elem.createSVGPoint();\n\t\tpoint.x = x - evt.view.scrollX;\n\t\tpoint.y = y - evt.view.scrollY;\n\t\treturn point.matrixTransform(matrix.inverse());\n\t};\n\n\t//\n\t// Called on mouse down in the chart.\n\t//\n\t$scope.mouseDown = function (evt) {\n\n\t\t$scope.chart.deselectAll();\n\n\t\tdragging.startDrag(evt, {\n\n\t\t\t//\n\t\t\t// Commence dragging... setup variables to display the drag selection rect.\n\t\t\t//\n\t\t\tdragStarted: function (x, y) {\n\t\t\t\t$scope.dragSelecting = true;\n\t\t\t\tvar startPoint = controller.translateCoordinates(x, y, evt);\n\t\t\t\t$scope.dragSelectionStartPoint = startPoint;\n\t\t\t\t$scope.dragSelectionRect = {\n\t\t\t\t\tx: startPoint.x,\n\t\t\t\t\ty: startPoint.y,\n\t\t\t\t\twidth: 0,\n\t\t\t\t\theight: 0,\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t//\n\t\t\t// Update the drag selection rect while dragging continues.\n\t\t\t//\n\t\t\tdragging: function (x, y) {\n\t\t\t\tvar startPoint = $scope.dragSelectionStartPoint;\n\t\t\t\tvar curPoint = controller.translateCoordinates(x, y, evt);\n\n\t\t\t\t$scope.dragSelectionRect = {\n\t\t\t\t\tx: curPoint.x > startPoint.x ? startPoint.x : curPoint.x,\n\t\t\t\t\ty: curPoint.y > startPoint.y ? startPoint.y : curPoint.y,\n\t\t\t\t\twidth: curPoint.x > startPoint.x ? curPoint.x - startPoint.x : startPoint.x - curPoint.x,\n\t\t\t\t\theight: curPoint.y > startPoint.y ? curPoint.y - startPoint.y : startPoint.y - curPoint.y,\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t//\n\t\t\t// Dragging has ended... select all that are within the drag selection rect.\n\t\t\t//\n\t\t\tdragEnded: function () {\n\t\t\t\t$scope.dragSelecting = false;\n\t\t\t\t$scope.chart.applySelectionRect($scope.dragSelectionRect);\n\t\t\t\tdelete $scope.dragSelectionStartPoint;\n\t\t\t\tdelete $scope.dragSelectionRect;\n\t\t\t},\n\t\t});\n\t};\n\n\t//\n\t// Called for each mouse move on the svg element.\n\t//\n\t$scope.mouseMove = function (evt) {\n\n\t\t//\n\t\t// Clear out all cached mouse over elements.\n\t\t//\n\t\t$scope.mouseOverConnection = null;\n\t\t$scope.mouseOverConnector = null;\n\t\t$scope.mouseOverNode = null;\n\n\t\tvar mouseOverElement = controller.hitTest(evt.clientX, evt.clientY);\n\t\tif (mouseOverElement == null) {\n\t\t\t// Mouse isn't over anything, just clear all.\n\t\t\treturn;\n\t\t}\n\n\t\tif (!$scope.draggingConnection) { // Only allow 'connection mouse over' when not dragging out a connection.\n\n\t\t\t// Figure out if the mouse is over a connection.\n\t\t\tvar scope = controller.checkForHit(mouseOverElement, controller.connectionClass);\n\t\t\t$scope.mouseOverConnection = (scope && scope.connection) ? scope.connection : null;\n\t\t\tif ($scope.mouseOverConnection) {\n\t\t\t\t// Don't attempt to mouse over anything else.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Figure out if the mouse is over a connector.\n\t\tvar scope = controller.checkForHit(mouseOverElement, controller.connectorClass);\n\t\t$scope.mouseOverConnector = (scope && scope.connector) ? scope.connector : null;\n\t\tif ($scope.mouseOverConnector) {\n\t\t\t// Don't attempt to mouse over anything else.\n\t\t\treturn;\n\t\t}\n\n\t\t// Figure out if the mouse is over a node.\n\t\tvar scope = controller.checkForHit(mouseOverElement, controller.nodeClass);\n\t\t$scope.mouseOverNode = (scope && scope.node) ? scope.node : null;\t\t\n\t};\n\n\t//\n\t// Handle mousedown on a node.\n\t//\n\t$scope.nodeMouseDown = function (evt, node) {\n\n\t\tvar chart = $scope.chart;\n\t\tvar lastMouseCoords;\n\n\t\tdragging.startDrag(evt, {\n\n\t\t\t//\n\t\t\t// Node dragging has commenced.\n\t\t\t//\n\t\t\tdragStarted: function (x, y) {\n\n\t\t\t\tlastMouseCoords = controller.translateCoordinates(x, y, evt);\n\n\t\t\t\t//\n\t\t\t\t// If nothing is selected when dragging starts, \n\t\t\t\t// at least select the node we are dragging.\n\t\t\t\t//\n\t\t\t\tif (!node.selected()) {\n\t\t\t\t\tchart.deselectAll();\n\t\t\t\t\tnode.select();\n\t\t\t\t}\n\t\t\t},\n\t\t\t\n\t\t\t//\n\t\t\t// Dragging selected nodes... update their x,y coordinates.\n\t\t\t//\n\t\t\tdragging: function (x, y) {\n\n\t\t\t\tvar curCoords = controller.translateCoordinates(x, y, evt);\n\t\t\t\tvar deltaX = curCoords.x - lastMouseCoords.x;\n\t\t\t\tvar deltaY = curCoords.y - lastMouseCoords.y;\n\n\t\t\t\tchart.updateSelectedNodesLocation(deltaX, deltaY);\n\n\t\t\t\tlastMouseCoords = curCoords;\n\t\t\t},\n\n\t\t\t//\n\t\t\t// The node wasn't dragged... it was clicked.\n\t\t\t//\n\t\t\tclicked: function () {\n\t\t\t\tchart.handleNodeClicked(node, evt.ctrlKey);\n\t\t\t},\n\n\t\t});\n\t};\n\n\t//\n\t// Handle mousedown on a connection.\n\t//\n\t$scope.connectionMouseDown = function (evt, connection) {\n\t\tvar chart = $scope.chart;\n\t\tchart.handleConnectionMouseDown(connection, evt.ctrlKey);\n\n\t\t// Don't let the chart handle the mouse down.\n\t\tevt.stopPropagation();\n\t\tevt.preventDefault();\n\t};\n\n\t//\n\t// Handle mousedown on an input connector.\n\t//\n\t$scope.connectorMouseDown = function (evt, node, connector, connectorIndex, isInputConnector) {\n\n\t\t//\n\t\t// Initiate dragging out of a connection.\n\t\t//\n\t\tdragging.startDrag(evt, {\n\n\t\t\t//\n\t\t\t// Called when the mouse has moved greater than the threshold distance\n\t\t\t// and dragging has commenced.\n\t\t\t//\n\t\t\tdragStarted: function (x, y) {\n\n\t\t\t\tvar curCoords = controller.translateCoordinates(x, y, evt);\n\n\t\t\t\t$scope.draggingConnection = true;\n\t\t\t\t$scope.dragPoint1 = flowchart.computeConnectorPos(node, connectorIndex, isInputConnector);\n\t\t\t\t$scope.dragPoint2 = {\n\t\t\t\t\tx: curCoords.x,\n\t\t\t\t\ty: curCoords.y\n\t\t\t\t};\n\t\t\t\t$scope.dragTangent1 = flowchart.computeConnectionSourceTangent($scope.dragPoint1, $scope.dragPoint2);\n\t\t\t\t$scope.dragTangent2 = flowchart.computeConnectionDestTangent($scope.dragPoint1, $scope.dragPoint2);\n\t\t\t},\n\n\t\t\t//\n\t\t\t// Called on mousemove while dragging out a connection.\n\t\t\t//\n\t\t\tdragging: function (x, y, evt) {\n\t\t\t\tvar startCoords = controller.translateCoordinates(x, y, evt);\n\t\t\t\t$scope.dragPoint1 = flowchart.computeConnectorPos(node, connectorIndex, isInputConnector);\n\t\t\t\t$scope.dragPoint2 = {\n\t\t\t\t\tx: startCoords.x,\n\t\t\t\t\ty: startCoords.y\n\t\t\t\t};\n\t\t\t\t$scope.dragTangent1 = flowchart.computeConnectionSourceTangent($scope.dragPoint1, $scope.dragPoint2);\n\t\t\t\t$scope.dragTangent2 = flowchart.computeConnectionDestTangent($scope.dragPoint1, $scope.dragPoint2);\n\t\t\t},\n\n\t\t\t//\n\t\t\t// Clean up when dragging has finished.\n\t\t\t//\n\t\t\tdragEnded: function () {\n\n\t\t\t\tif ($scope.mouseOverConnector && \n\t\t\t\t\t$scope.mouseOverConnector !== connector) {\n\n\t\t\t\t\t//\n\t\t\t\t\t// Dragging has ended...\n\t\t\t\t\t// The mouse is over a valid connector...\n\t\t\t\t\t// Create a new connection.\n\t\t\t\t\t//\n\t\t\t\t\t$scope.chart.createNewConnection(connector, $scope.mouseOverConnector);\n\t\t\t\t}\n\n\t\t\t\t$scope.draggingConnection = false;\n\t\t\t\tdelete $scope.dragPoint1;\n\t\t\t\tdelete $scope.dragTangent1;\n\t\t\t\tdelete $scope.dragPoint2;\n\t\t\t\tdelete $scope.dragTangent2;\n\t\t\t},\n\n\t\t});\n\t};\n}])\n;\n","undoManager":{"mark":-1,"position":0,"stack":[[{"group":"doc","deltas":[{"start":{"row":140,"column":0},"end":{"row":141,"column":0},"action":"remove","lines":["\t\tif (hasClassSVG(element, parentClass)) {",""]},{"start":{"row":139,"column":0},"end":{"row":140,"column":0},"action":"insert","lines":["\t\tif (hasClassSVG(element, parentClass)) {",""]}]}]]},"ace":{"folds":[],"scrolltop":1858.8333778381348,"scrollleft":0,"selection":{"start":{"row":139,"column":14},"end":{"row":139,"column":17},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1421450276989}